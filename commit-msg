#!/bin/bash
#
# git-subrepo pre-commit hook
# Split up commits between main and subrepo commits at commit time
#
# Copyright (C) Brecht Machiels <brecht@mos6581.org>
#

. git-sh-setup

require_work_tree

debug=1
subdir="sub"

debug()
{
	if [ -n "$debug" ]; then
		echo "$@" >&2
	fi
}

say()
{
	if [ -z "$quiet" ]; then
		echo "$@" >&2
	fi
}

assert()
{
	if "$@"; then
		:
	else
		die "assertion failed: " "$@"
	fi
}


find_last_subrepo_commit()
{
    subdir="$1"
    
    debug "Locating previous subrepo merge commit"
    git rev-list --merges --parents --topo-order HEAD |
    while read rev main_parent parents; do
        subrepo_parent=$(get_subrepo_parent "$rev" "$parents" "$subdir")
        if [[ -n $subrepo_parent ]]; then
            #debug "  $rev is a subrepo merge commit!"
            echo $subrepo_parent
            break
        else
            #debug "  $rev is not a subrepo merge commit"
            continue
        fi
    done || exit $?
}

get_subrepo_parent()
{
    rev="$1"
    parents="$2"
    subdir="$3"
    
    subrepo_tree=$(subtree_for_commit $rev $subdir)
    for parent in $parents; do
        parent_tree=$(toptree_for_commit $parent)
        if [[ "$parent_tree" = "$subrepo_tree" ]]; then
            echo $parent
        fi
    done || exit $?
}

toptree_for_commit()
{
	commit="$1"
	# TODO: replace with plumbing
	git show -s --format=format:%T "$commit" -- || exit $?
}

subtree_for_commit()
{
	commit="$1"
	dir="$2"

	git ls-tree "$commit" -- "$dir" |
	while read mode type tree name; do
		assert [ "$name" = "$dir" ]
		assert [ "$type" = "tree" -o "$type" = "commit" ]
		[ "$type" = "commit" ] && continue  # ignore submodules
		echo $tree
		break
	done
}

has_subrepo_changes()
{
    subdir="$1"
    
    ! git diff-index --cached --exit-code --quiet HEAD -- "$subdir"
}

clone_commit()
{
    source_commit="$1"
    tree="$2"
    parents="$3"

	# We're going to set some environment vars here, so
	# do it in a subshell to get rid of them safely later
	git log -1 --pretty=format:'%an%n%ae%n%ad%n%cn%n%ce%n%cd%n%B' "$source_commit" |
	(
		read GIT_AUTHOR_NAME
		read GIT_AUTHOR_EMAIL
		read GIT_AUTHOR_DATE
		read GIT_COMMITTER_NAME
		read GIT_COMMITTER_EMAIL
		read GIT_COMMITTER_DATE
		export  GIT_AUTHOR_NAME \
			GIT_AUTHOR_EMAIL \
			GIT_AUTHOR_DATE \
			GIT_COMMITTER_NAME \
			GIT_COMMITTER_EMAIL \
			GIT_COMMITTER_DATE
		(echo -n "$annotate"; cat ) |
		git commit-tree $parents $tree  # reads the rest of stdin
	) || die "Can't clone commit $source_commit"
}

main()
{
    if has_subrepo_changes $subdir; then
        say "Commit has subrepo changes. Splitting this commit."
        last_subrepo_commit=$(find_last_subrepo_commit $subdir)
        if [[ -z $last_subrepo_commit ]]; then
            say "No existing subrepo merge commit found in history. Aborting."
            say "You can split off your subrepo commits like so:"
            say "   git subtree split --prefix=$subdir -b subtree/$subdir"
            say "And merge the newly created branch with your main repository:"
            say "   git merge -s subtree subtree/$subdir" # force path with -Xsubtree= 
            exit 1
        fi
        #debug "last subrepo commit: $last_subrepo_commit"

        subrepo_tree=$(git write-tree --prefix="$subdir")
        echo "subrepo_tree = $subrepo_tree"
        #subrepo_commit=$(clone_commit $last_commit $subrepo_tree "-p $last_subrepo_commit")
        subrepo_commit=$(git commit-tree -p $last_subrepo_commit $subrepo_tree -m "meh")
        echo "subrepo_commit = $subrepo_commit"
        
        echo $PWD

        cat .git/MERGE_HEAD
        echo $subrepo_commit > .git/MERGE_HEAD
        echo "$subrepo_commit > .git/MERGE_HEAD"
        
        cat .git/ORIG_HEAD
    fi
}

#main
